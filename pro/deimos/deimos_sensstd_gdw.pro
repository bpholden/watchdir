;------------------------------------------------------------------------
pro deimos_sensstd_gdw, std_fil, CLOBBER=clobber, CONDITIONS=conditions, $
  NO_UPD_WEB=no_upd_web, EXPTIME=exptime, PLOT=plot, COMPRESS=compress, $
  VERBOSE=verbose
;------------------------------------------------------------------------
;+
; NAME:
;	DEIMOS_SENSSTD_GDW
;
; PURPOSE:
;	Process DEIMOS observations of standard stars to measure zero
;	points and system efficiency.
;
; CATEGORY:
;	Instrument performance monitoring
;
; CALLING SEQUENCE:
;       deimos_sensstd_gdw, std_fil
;
; INPUTS:
;	std_file:       FITS binary table with spectrum and metadata
;	as generated by deimos_throughput.pro 
;
; KEYWORD PARAMETERS:
;       CLOBBER:        set this to overwrite existing files
;
;       CONDITIONS:     set this to a string which will be included in
;       the metdata to indicate observing conditions
;
;       NO_UPD_WEB:     do not update web pages (takes a long time)
;
;       EXPTIME:        set exposure time to N seconds.  Usually this
;       will be 1 if the input data are already converted to e-/sec
;       [default=1] 
;
;       COMPRESS:       set to compress the output file using the
;       specified program
;
; ENVIRONMENT VARIABLES:
;       DEIMOS_CALIBS:  name of directory in which to write output
;       files
;
; DATA PRODUCTS:
;       Generates plots and tables documenting the system throughput.
;
; INPUT FILES:
;       std_fil = output FITS binary table from deimos_throughput.pro
;       cal_fil = standard star flux file from XIDL_DIR
;
; OUTPUT FILES:
;       outfil = output file [$DEIMOS_CALIBS/<grating>/sens_<grating>_DDMMMYYYY_NNNN.fits]
;
; PROCEDURE:
;
; EXAMPLE:
;
; AUTHOR:
;	Jason X. Prochaska, UCO/Lick Observatory
;
; MODIFICATION HISTORY:
;       12-Jan-2008     JXP     v1.0    Original version
;       2009-Oct-23     GDW     v1.1    Added header doco
;-
;------------------------------------------------------------------------

if  N_params() LT 1  then begin 
    print,'Syntax - ' + $
          'deimos_sensstd_gdw, std_fil [v1.1]'
    return
endif 

;; process keywords...
if not keyword_set(EXPTIME) then exptime = 1. 

;; verify existence of input file...
if ~ file_test(STD_FIL) then begin
    message, 'Input file not found: '+std_fil, /info
    return
endif

;; Grab meta data...
if keyword_set(VERBOSE) then $
  message, 'reading HDU 1 from std_file '+std_file, /info
t_meta = xmrdfits(std_fil,1,/silen)
meta = {thrustrct}
copy_struct, t_meta, meta

;; remove spaces from grating name...
meta.grating = strtrim(meta.grating,2)
mgrat = meta.grating

;; process conditions...
if keyword_set(CONDITIONS) then begin
    meta.conditions = conditions
endif else begin
    meta.conditions = ' '
endelse

;; build output file name...
subdir = getenv('DEIMOS_CALIBS')+'/'+mgrat

;; Create the directory if necessary...
if ~ file_test( subdir, /DIRECTORY) then begin
    file_mkdir, subdir
    file_mkdir, subdir+'/THRU_DIR'
endif

;; build output filename...
outfil = subdir+'/sens_'+mgrat+ $
         '_'+meta.date+'_'+ x_padstr(meta.frame,4,'0', /TRIM,/REVERSE)+'.fits'

;; Check for existence of output file...
if file_test( outfil) or file_test( outfil+'.gz') then begin
    if keyword_set(CLOBBER) then begin
        if file_test( outfil)       then file_delete, outfil 
        if file_test( outfil+'.gz') then file_delete, outfil+'.gz'
    endif else begin
        message, 'Operation would clobber existing output file '+outfil, /info
        return
    endelse
endif 

;; verify that standard star is acceptable...
x_stdcalibfil, meta.ra, meta.dec, calibfil, std_name
if strlen(calibfil) EQ 0 then begin
    message, 'invalid standard star based on RA/Dec -- skipping', /info
    return
endif
meta.std_name = std_name

;; Read in data
if keyword_set(VERBOSE) then $
  message, 'reading HDU 2 from std_file '+std_file, /info
spectrum = xmrdfits(std_fil, 2, /silen)
box_wave = spectrum.wavelength
box_fx = spectrum.counts / exptime ;; electrons/s/pix

;; Get sensitivity function
cal_fil = getenv('XIDL_DIR')+$
          '/Spec/Longslit/calib/standards/calspec/'+calibfil
if keyword_set(VERBOSE) then $
  message, 'reading HDU 1 from cal_file '+cal_file, /info
std = xmrdfits(cal_fil,1)
std_wv = std.wavelength
c = x_constants()
std_fx = std.flux * (std_wv)^2 * 1d-8 / c.c ;; fnu
std_ab = -2.5*alog10(std_fx) - 48.6  ;; AB mag

;; Fit smooth function to the sensitivity function
fitstr = x_setfitstrct(FUNC='LEGEND', NORD=4L, LSIG=3., HSIG=3., $
                       FLGREJ=1)

;; define wavelength regions to ignore due to atmospheric features
rej_wv = [ $
         [4460, 4524.], $
         [4853, 4872.], $       ; H beta
         [5014, 5048.], $
         [6273, 6301.], $
         [6884, 6991.], $       ; B band
         [7584, 7767.] $        ; A band
         ]
sz_rej = size(rej_wv, /dimen)

npix = n_elements(box_wave)
sv_wv = dblarr(npix)
sv_sens = fltarr(npix)
sv_sens2 = fltarr(npix)

;; Get the standard values
linterp, std_wv, std_fx, box_wave, fx
box_fx = box_fx / fx

;; Mask out bad regions defined in rej_wv...
msk = replicate(1B,npix)
for ss=0L,sz_rej[1]-1 do begin
    bd = where( box_wave GT rej_wv[0,ss] and $
                box_wave LT rej_wv[1,ss], nbd)
    if nbd NE 0 then msk[bd] = 0B
endfor

;; Smooth the data...
fit = smooth(box_fx, 11)

;; compute dmv = width of each pixel in AA...
allwv = box_wave
dwv = allwv - shift(allwv,1) 
dwv[0] = dwv[1]

;; compute sensitivity per pixel and per AA...
allsens = 1./fit
allsens2 = 1./(fit / dwv)  ;;   1/[electrons/Ang/flux] (Fnu)

;; Convert to AB
allsens = -2.5*alog10(allsens) - 48.6 ; per pixel
allsens2 = -2.5*alog10(allsens2) - 48.6 ; per AA

;; bin the data into nbins bins...
nbins = 1000
npix = n_elements(allwv)
step = npix/float(nbins)
idx = round(lindgen(nbins-1)*step)
allsens = allsens[idx]
allsens2 = allsens2[idx]
allwv = allwv[idx]

;; generate plots...
if keyword_set(PLOT) then x_splot, allwv, allsens, /blo
if keyword_set(PLOT) then x_splot, allwv, allsens2, /blo

;; apply extinction correction...
mkhdr, head, allwv
sxaddpar, head, 'TELESCOP', 'Keck'
sxaddpar, head, 'ELAPTIME', 1.
sxaddpar, head, 'AIRMASS', meta.airmass
extinct = long_extinct(allwv, head, /NOTIME)

;; Efficiency
x_initkeck, telescope 
linterp, std_wv, std_fx, allwv, all_std  ;; fnu (erg/s/cm^2/Hz)
nphot = telescope.area * all_std * 1. / (c.h * allwv)         ;; Trust me
nobs = all_std / 10.^(-1.*(allsens2+48.6)/2.5) 
eff = (nobs*extinct)/nphot
if keyword_set(PLOT) then x_splot, allwv, (nobs/nphot), /bloc

;; write datafile...
out_str = { $
          wav: allwv, $
          zp_pix: allsens, $
          zp_ang: allsens2, $
          eff: eff $
          }
mwrfits, meta, outfil, /create
mwrfits, out_str, outfil

;; compress if desired...
if keyword_set(COMPRESS) then begin
    command = compress + ' ' + outfil
    spawn, command
endif

end
